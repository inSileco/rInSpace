[["index.html", "R in Space - Custom mapping Chapter 1 Introduction ", " R in Space - Custom mapping David Beauchesne, Mari-Hélène, Nicolas Casajus, Kevin Caelles, Elliot Dreujou, Steve Vissault 2023-02-08 Chapter 1 Introduction "],["so-it-begins.html", "1.1 So it begins", " 1.1 So it begins A fair proportion of people involved in inSileco have one particular expertise in common: we work extensively with spatial data. This expertise has been developed through extensive time importing, creating and formatting spatial data, performing spatial analyses and building static and dynamic spatial visualizations. In this blog post series, we propose an educational tour of spatial possibilities offered by tools developed in the R environment. This series could thus be used in an educational setting to learn how to use R in Space! As is our usual habit, rather than creating a series of posts presenting specific tools, we will first ask a series of explicitly spatial and ecological questions and go through the possibilities offered by R to play around with spatial tools. Back in 2018, this was a series of blogpost, we turned in into a bookdown in 2021. "],["beginner-course.html", "1.2 Beginner course", " 1.2 Beginner course Useful resources: curated list of valuable resources About spatial objects Importing spatial objects Basic mapping "],["advanced-course.html", "1.3 Advanced course", " 1.3 Advanced course Attribute manipulation Geometry manipulation R spatial data resources Custom maps "],["sessioninfo.html", "1.4 SessionInfo", " 1.4 SessionInfo sessionInfo() #R&gt; R version 4.2.2 (2022-10-31) #R&gt; Platform: x86_64-pc-linux-gnu (64-bit) #R&gt; Running under: Ubuntu 22.04.1 LTS #R&gt; #R&gt; Matrix products: default #R&gt; BLAS: /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3 #R&gt; LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so #R&gt; #R&gt; locale: #R&gt; [1] LC_CTYPE=C.UTF-8 LC_NUMERIC=C LC_TIME=C.UTF-8 #R&gt; [4] LC_COLLATE=C.UTF-8 LC_MONETARY=C.UTF-8 LC_MESSAGES=C.UTF-8 #R&gt; [7] LC_PAPER=C.UTF-8 LC_NAME=C LC_ADDRESS=C #R&gt; [10] LC_TELEPHONE=C LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C #R&gt; #R&gt; attached base packages: #R&gt; [1] stats graphics grDevices utils datasets methods base #R&gt; #R&gt; loaded via a namespace (and not attached): #R&gt; [1] bookdown_0.32 digest_0.6.31 R6_2.5.1 jsonlite_1.8.4 #R&gt; [5] evaluate_0.20 cachem_1.0.6 rlang_1.0.6 cli_3.6.0 #R&gt; [9] jquerylib_0.1.4 bslib_0.4.2 rmarkdown_2.20 tools_4.2.2 #R&gt; [13] xfun_0.37 yaml_2.3.7 fastmap_1.1.0 compiler_4.2.2 #R&gt; [17] htmltools_0.5.4 knitr_1.42 sass_0.4.5 "],["useful-resources.html", "Chapter 2 Useful resources ", " Chapter 2 Useful resources "],["the-mapping-landscape-has-changed.html", "2.1 The mapping landscape has changed!", " 2.1 The mapping landscape has changed! Over the last decade it has become increasingly easy to create and edit maps. As explained by Mark Zastrow in “Science on the Map”, the mapping landscape has dramatically changed over the last decade. Scientists can now readily draw valuable spatial representations of their work, even with large data sets and perform powerful analyses using specific packages of programming languages such as R and Python. In order to give you a taste of the diversity of tool to manipulate, analyze and visualize geographic information, we listed a few software available: 2.1.1 Geographic Information System (GIS) Quantum GIS; ArcGIS; DIVA-GIS; GRASS GIS; PostGIS; SAGA GIS. 2.1.2 Web mapping tools CartoDB; GeoJson; Google Map; Goole Earth; OpenStreetmap; Mapbox. 2.1.3 Specific packages of various programming languages 2.1.3.1 C/C++ libraries: proj4; gdal; geos. 2.1.3.2 JavaScript: Leaflet Turf more information here 2.1.3.3 Julia packages JuliaGeo. 2.1.3.4 Python packages cartopy; geopy; more information here. And if you want to see MORE, look at the Awesome GIS and the Awesome Geospatial :fire:! 2.1.4 Free GIS data If you are looking for free GIS data, you should definitively start by carefully examine the resources listed on this page: https://freegisdata.rtwilson.com/. Note that in R the function getData() from the raster package is fantastic and some R packages are great data provider, for instance, osmdata (see below). "],["so-why-use-r-for-mapping.html", "2.2 So… why use R for mapping?", " 2.2 So… why use R for mapping? Given the number of tools dedicated to visualization and analyses of spatial data, it is important that users ask this question and take some time to balance pros and cons of using R for mapping. According to us, the choice strongly relies on: your ambition in terms of mapping; your skills in R. If you aim at creating a good-looking map without analysis and you are not familiar with R, it does not make sense to use R only for mapping. But if you are familiar with R or plan on becoming familiar with it to perform and replicate spatial analyses in R, you can quickly get a good-looking map (a R plot basically) and then benefit from the plot system you already know. Also, when you need tricky spatial analysis, even if you are not familiar with R, you will doubtlessly may benefit from learning it. Using R to create your maps and perform spatial analyses also means that you will write your data pipeline in a specific language and thus create scripts. Such scripts are easy to share and key element to make your analyses transparent and reproducible. Last but not least, the vast and active R community, which explains the incredible richness of packages, the abundance of documentation and tutorials available on line as well as the massive stack of answered questions on question and answer sites such as StackOverflow. For a detailed list of packages, have a look at the CRAN task view “Spatial”. Note that there is a quick way to install all packages listed in the task view through the package: install.packages(&quot;ctv&quot;) ctv::install.views(&quot;Spatial&quot;) Also, according to us, a good set of tutorials/documentation to start with spatial data in R is: r-spatial.org; rspatial.org; A DataCamp tutorial; Geocomputation with R; Analyses spatiale sous R (fr). Another tutorial by Claudia Engel "],["about-spatial-data.html", "Chapter 3 About spatial data", " Chapter 3 About spatial data Spatial data refer to phenomenon or information that can be observed geographically. What a definition! In short spatial data concern every information that could be reported on a map, i.e. on a two-dimensions geographical coordinates system. Two kinds of spatial data exist: vector data and raster data. Generally vectors refer to discrete locations, i.e. objects with boundaries (for instance a city, a road, a country) whereas raster data refer to continuous phenomenon that can be observed everywhere, but without natural boundaries (for instance the surface temperature). Let’s take a look at their characteristics. "],["vector-data.html", "3.1 Vector data", " 3.1 Vector data Vector data consist of the description of a spatially explicit phenomenon geometry (position and coordinates of its boundaries in a specific spatial referential). In addition to this geometry, vector data may contain variables (or attributes) with additional information about the phenomenon at each location. For instance, cities of a country are vector data (points) and attributes could be cities names, population sizes, etc. Borders of a country are also vector data (polygons) and could contain the name of the country, the population for a given year, and the mean number of crimes as attributes. There are main symbol types for vector data: points, lines and polygons. The geometry of these data structures consists of sets of geographical coordinate pairs (longitude, latitude) in a specific Coordinate Reference System (CRS). 3.1.1 Points data Points are the simplest vector object. Each point has one two-dimensional coordinates, and several associated variables. For instance, a point might represent a location where an animal was trapped, and the attributes could include the capture date, the size, the sex, and information about the physical environment. #R&gt; Loading required package: sp 3.1.2 Lines data Lines are the second type of vector data. A line is a shape consisting of one or several segments (or paths) and each segment has two noteworthy points (or vertex): a starting point and an ending point. Note that the ending point of a segment will have the same coordinates as the starting point of the following segment in the case of a line consisting of connected segments. In other words, a line with one segment is defined by two coordinates pairs (longitude and latitude). A line with two connected segments is defined by three coordinates pairs and a line with two isolated segments is defined by four coordinates pairs. Thus, the representation of a line is very similar to that of a collection of points. The main difference is that the ordering of the points is important, because we need to know which points should be connected two-by-two. 3.1.3 Polygons data Polygons are closed spatial lines where the coordinates of the starting point of the first segment is identical to the ending point of the last segment. The geometry of a polygon is very similar to that of a line but polygons have three characteristics: a polygon cannot self-intersect (whereas a line can), a polygon can contain hole (think about the state of Vatican overlapping the country of Italy but considered as a separated polygon), as a closed feature, a polygon has an inside and a border. Vector data are generally stored in ESRI Shapefile, GeoJSON, KML or Simple Features files. In R, two main packages exist to handle spatial vector data: sp and sf. Note that the package rgdal will be used to import/export vector data (go next post to learn more). "],["raster-data.html", "3.2 Raster data", " 3.2 Raster data Raster data are commonly used to represent continuous phenomenon that can be observed everywhere, but without natural boundaries (but with artificial boundaries defined by the user). A raster consists of a grid of equally sized cells (or pixels) that all have a values (or a missing value) for one single variable. Unlike vector data, the geometry of raster data is not explicitly stored as coordinates. Rather it is implicitly set by setting the spatial extent and the number of rows and columns of a regular grid. From this spatial information, the size of the raster cells (spatial resolution) can be computed. Working with raster data will therefore be more efficient than working with polygons data. Raster can be used to represent a very broad range of data: continuous (temperature values), discrete (habitat classes) or even binary (species occurrence) variables. #R&gt; Please note that rgdal will be retired during 2023, #R&gt; plan transition to sf/stars/terra functions using GDAL and PROJ #R&gt; at your earliest convenience. #R&gt; See https://r-spatial.org/r/2022/04/12/evolution.html and https://github.com/r-spatial/evolution #R&gt; rgdal: version: 1.6-4, (SVN revision 1196) #R&gt; Geospatial Data Abstraction Library extensions to R successfully loaded #R&gt; Loaded GDAL runtime: GDAL 3.4.1, released 2021/12/27 #R&gt; Path to GDAL shared files: /usr/share/gdal #R&gt; GDAL binary built with GEOS: TRUE #R&gt; Loaded PROJ runtime: Rel. 8.2.1, January 1st, 2022, [PJ_VERSION: 821] #R&gt; Path to PROJ shared files: /home/runner/.local/share/proj:/usr/share/proj #R&gt; PROJ CDN enabled: FALSE #R&gt; Linking to sp version:1.6-0 #R&gt; To mute warnings of possible GDAL/OSR exportToProj4() degradation, #R&gt; use options(&quot;rgdal_show_exportToProj4_warnings&quot;=&quot;none&quot;) before loading sp or rgdal. Several file formats exist to store raster data. The most commons are: GeoTIFF, NetCDF, grd and ascii formats. Even the package rgdal can be used to import/export raster data, we will prefer the package raster. "],["vector-objects-in-r.html", "3.3 Vector objects in R", " 3.3 Vector objects in R In this section we present two packges: sp and sf. The sp package actualy defines classes for both vector and raster objects. Below, we however focus on the vector ones and so we do not detail SpatialGrid and SpatialPixels objects. Also note that sf “[…] aims at succeeding sp in the long term” (Simple Features for R, sf vignette). Let first create a data frame mydata: mylon &lt;- -82 + 2 * runif(20) mylat &lt;- 42 + 2 * runif(20) mydata &lt;- data.frame( lon = mylon, lat = mylat, var1 = rnorm(20), var2 = 10 * runif(20) ) Let’s have a look at thus data frame: lon lat var1 var2 -81.03876 42.94418 0.1110215 5.591651 -81.39501 42.73904 0.6644820 8.010553 -80.46684 43.70218 2.2764582 1.790977 -81.52099 43.49017 0.5213265 5.067142 -81.29007 42.58602 2.2475670 7.690447 -81.57360 42.57142 0.8358582 2.518603 3.3.1 Package sp 3.3.1.1 Classes The table below includes a description of the classes for points, lines and polygons. Basically all these classes work the same way. For instance, in order to define a SpatialPointsDataPoints object, three elements are required: a set of coordinates, a Coordinate Reference System (CRS) and an attribute table. Intermediate class are also defined (for instance points + CRS = SpatialPoints) and the name of the class is also the name of the function to be called. Classes and functions Contents Points list of points (set of coordinates) SpatialPoints list of points + CRS SpatialPointsDataPoints list of points + CRS + attribute table Line a line (set of coordinates) Lines list of lines SpatialLines list of lines + CRS SpatialLinesDataFrame list of lines + CRS + attribute table Polygon a line (set of coordinates) Polygons list of lines SpatialPolygons list of lines + CRS SpatialPolygonsDataFrame list of lines + CRS + attribute table 3.3.1.2 SpatialPointsDataFrame As an more tangible example, let’s now create a SpatialPointsDataFrame based on our data frame mydata. library(sp) mysp &lt;- SpatialPointsDataFrame( coords = mydata[, 1:2], data = mydata[, 3:4], proj4string = CRS( &quot;+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs +towgs84=0,0,0&quot; ) ) Note that proj4 is used and we therefore wrote a string that describes the CRS and that proj4 understands. Below are listed some properties of the object we have defined. isS4(mysp) class(mysp) slotNames(mysp) dim(mysp) #R&gt; [1] TRUE #R&gt; [1] &quot;SpatialPointsDataFrame&quot; #R&gt; attr(,&quot;package&quot;) #R&gt; [1] &quot;sp&quot; #R&gt; [1] &quot;data&quot; &quot;coords.nrs&quot; &quot;coords&quot; &quot;bbox&quot; &quot;proj4string&quot; #R&gt; [1] 20 2 Basically, it is a S4 object of class SpatialPointsDataFrame. All slot names refer to attribute that are accessible via and @: mysp@proj4string #R&gt; Coordinate Reference System: #R&gt; Deprecated Proj.4 representation: +proj=longlat +datum=WGS84 +no_defs #R&gt; WKT2 2019 representation: #R&gt; GEOGCRS[&quot;unknown&quot;, #R&gt; DATUM[&quot;World Geodetic System 1984&quot;, #R&gt; ELLIPSOID[&quot;WGS 84&quot;,6378137,298.257223563, #R&gt; LENGTHUNIT[&quot;metre&quot;,1]], #R&gt; ID[&quot;EPSG&quot;,6326]], #R&gt; PRIMEM[&quot;Greenwich&quot;,0, #R&gt; ANGLEUNIT[&quot;degree&quot;,0.0174532925199433], #R&gt; ID[&quot;EPSG&quot;,8901]], #R&gt; CS[ellipsoidal,2], #R&gt; AXIS[&quot;longitude&quot;,east, #R&gt; ORDER[1], #R&gt; ANGLEUNIT[&quot;degree&quot;,0.0174532925199433, #R&gt; ID[&quot;EPSG&quot;,9122]]], #R&gt; AXIS[&quot;latitude&quot;,north, #R&gt; ORDER[2], #R&gt; ANGLEUNIT[&quot;degree&quot;,0.0174532925199433, #R&gt; ID[&quot;EPSG&quot;,9122]]]] head(mysp@data) #R&gt; var1 var2 #R&gt; 1 0.1110215 5.591650 #R&gt; 2 0.6644820 8.010553 #R&gt; 3 2.2764582 1.790977 #R&gt; 4 0.5213265 5.067142 #R&gt; 5 2.2475670 7.690447 #R&gt; 6 0.8358582 2.518603 In order to change projection, the user must call spTransform(), like so: (mysp2 &lt;- spTransform(mysp, CRS=CRS(&quot;+proj=merc +ellps=GRS80&quot;))) #R&gt; class : SpatialPointsDataFrame #R&gt; features : 20 #R&gt; extent : -9118633, -8957527, 5159576, 5389937 (xmin, xmax, ymin, ymax) #R&gt; crs : +proj=merc +lon_0=0 +k=1 +x_0=0 +y_0=0 +ellps=GRS80 +units=m +no_defs #R&gt; variables : 2 #R&gt; names : var1, var2 #R&gt; min values : -2.12149445648486, 0.957436570897698 #R&gt; max values : 2.2764581628672, 9.31604944868013 3.3.2 Package sf Below is a very short overview of classes in sf, the reader that requires further explanation would find more details on the first vignette of sf. Basically three classes are defined: sf, sfc and sfg. 3.3.2.1 Class sf library(sf) #R&gt; Linking to GEOS 3.10.2, GDAL 3.4.1, PROJ 8.2.1; sf_use_s2() is TRUE pts_sf &lt;- st_as_sf( x = mydata, coords = c(&quot;lon&quot;, &quot;lat&quot;), crs = 4326 ) Let’s examine its class class(pts_sf) #R&gt; [1] &quot;sf&quot; &quot;data.frame&quot; 3.3.2.2 Class sfc pts_sfc &lt;- st_geometry(pts_sf) class(pts_sfc) #R&gt; [1] &quot;sfc_POINT&quot; &quot;sfc&quot; 3.3.2.3 Class sfg (x &lt;- st_point(c(1, 2))) #R&gt; POINT (1 2) class(x) #R&gt; [1] &quot;XY&quot; &quot;POINT&quot; &quot;sfg&quot; 3.3.2.4 How to import a sp object st_as_sf() can also be used to convert a sp object into a sf one. st_as_sf(mysp) #R&gt; Simple feature collection with 20 features and 2 fields #R&gt; Geometry type: POINT #R&gt; Dimension: XY #R&gt; Bounding box: xmin: -81.91407 ymin: 42.18196 xmax: -80.46684 ymax: 43.70218 #R&gt; CRS: +proj=longlat +datum=WGS84 +no_defs #R&gt; First 10 features: #R&gt; var1 var2 geometry #R&gt; 1 0.1110215 5.591650 POINT (-81.03876 42.94418) #R&gt; 2 0.6644820 8.010553 POINT (-81.39501 42.73904) #R&gt; 3 2.2764582 1.790977 POINT (-80.46684 43.70218) #R&gt; 4 0.5213265 5.067142 POINT (-81.52099 43.49017) #R&gt; 5 2.2475670 7.690447 POINT (-81.29007 42.58602) #R&gt; 6 0.8358582 2.518603 POINT (-81.5736 42.57142) #R&gt; 7 0.4324725 4.854437 POINT (-81.85505 43.30567) #R&gt; 8 -1.0001346 5.265450 POINT (-81.32604 42.18196) #R&gt; 9 -0.7722097 4.248399 POINT (-81.89046 42.54436) #R&gt; 10 0.6212614 7.869162 POINT (-81.63948 42.46887) "],["raster-objects-in-r.html", "3.4 Raster objects in R", " 3.4 Raster objects in R The R package raster provides three main classes of raster object (more details here): RasterLayer imports a single-layer (variable) raster, RasterStack imports in one single object several single-layer (variable) rasters stored in one or different files, RasterBrick imports in one single object several single-layer (variable) rasters stored in one single file. Using RasterStack and RasterBrick requires that the geometry of all raster data is equal. Package raster define three classes of rater object we detail below. 3.4.1 RasterLayer library(raster) val1 &lt;- matrix(runif(100 * 100, 0, 10), ncol = 100, nrow = 100) ras1 &lt;- raster( val1, crs = CRS(&quot;+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0&quot;), xmn = -82, xmx = +80, ymn = +42, ymx = +44 ) class(ras1) #R&gt; [1] &quot;RasterLayer&quot; #R&gt; attr(,&quot;package&quot;) #R&gt; [1] &quot;raster&quot; dim(ras1) #R&gt; [1] 100 100 1 head(values(ras1)) #R&gt; [1] 0.4088394 4.4199565 3.4096969 8.3125694 7.5901618 5.2882679 projection(ras1) #R&gt; [1] &quot;+proj=longlat +datum=WGS84 +no_defs&quot; 3.4.2 RasterStack and RasterBrick http://www.rspatial.org/spatial/rst/4-rasterdata.html#rasterstack-and-rasterbrick Let’s first create another raster (with the same CRS) val2 &lt;- matrix(rnorm(100 * 100), ncol = 100, nrow = 100) ras2 &lt;- raster( val2, crs = CRS(&quot;+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0&quot;), xmn = -82, xmx = +80, ymn = +42, ymx = +44 ) class(ras2) #R&gt; [1] &quot;RasterLayer&quot; #R&gt; attr(,&quot;package&quot;) #R&gt; [1] &quot;raster&quot; Let’s stack() ras1 and ras2: sta1 &lt;- stack(ras1, ras2) class(sta1) #R&gt; [1] &quot;RasterStack&quot; #R&gt; attr(,&quot;package&quot;) #R&gt; [1] &quot;raster&quot; Let’s brick() them: bri1 &lt;- brick(ras1, ras2) class(bri1) #R&gt; [1] &quot;RasterBrick&quot; #R&gt; attr(,&quot;package&quot;) #R&gt; [1] &quot;raster&quot; "],["import-spatial-objects.html", "Chapter 4 Import spatial objects ", " Chapter 4 Import spatial objects "],["reading-and-writing-spatial-objects-with-sf-and-raster.html", "4.1 Reading and writing spatial objects with sf and raster", " 4.1 Reading and writing spatial objects with sf and raster Spatial data are encoded in various GIS file formats such as Shapefiles (.shp), Geodatabase (.gdb), GeoPackage (.gpkg) and GeoJSON (.geojson), GeoTIFF (.tiff). In this post we show how to read commonly used formats and import the data they include in you R session. We start by describing the steps to turn a set of coordinates included in a .csv file into a spatial object and write it to a GIS file format. We then exemplify the use of two functions: st_read() from the sf package and raster() from the raster package and import different GIS file available on the Portail de données ouvertes de Montreal. Let us start by loading the packages required: library(sf) library(raster) "],["import-spatial-data-from-.csv-file.html", "4.2 Import spatial data from .csv file", " 4.2 Import spatial data from .csv file Spatial data are sometimes stored in a text file format (.txt or .csv), in such case columns providing the coordinates must be included and the user must know the CRS (Coordinate Reference System). A sf object allows us to store both the coordinates of each point as well as associated attribute data, i.e. columns describing each feature in the spatial object. The dataset we work with below represents sampling points of a monitoring program of water quality in Montreal (available here). # Download csv file from web page in your working directory if (!file.exists(&quot;data/ruisso.csv&quot;)) { download.file( &quot;https://data.montreal.ca/dataset/86843d31-4251-4002-b10d-620aaa751092/resource/adad6c48-fb48-40fc-a031-1ac870d978b4/download/stations_ruisso.csv&quot;, destfile = &quot;data/ruisso.csv&quot; ) } # Read csv file in R pts &lt;- read.csv(&quot;data/ruisso.csv&quot;, header = TRUE, dec = &quot;,&quot;) 4.2.1 Convert a data frame to simple feature objects The data frame containing sampling points can be converted into simple feature objects using st_as_sf(). To do so, we need to specify where coordinates are, i.e. columns LATITUDE and LONGITUDE as well as the CRS. In our example, the CRS is specified in the metadata of the data set: the datum is WGS84 and the EPSG is 4326. Remember that without the CRS, you cannot locate correctly your coordinates on the Earth’s surface. In the package sf, the reference system can be define using the proj4 format or directly with the EPSG code. pts_sf &lt;- st_as_sf( x = pts, coords = c(&quot;LONGITUDE&quot;, &quot;LATITUDE&quot;), crs = 4326 ) head(pts_sf) #R&gt; Simple feature collection with 6 features and 5 fields #R&gt; Geometry type: POINT #R&gt; Dimension: XY #R&gt; Bounding box: xmin: -73.93704 ymin: 45.43462 xmax: -73.9012 ymax: 45.45022 #R&gt; Geodetic CRS: WGS 84 #R&gt; Plan.d.eau Point.d.échantillonnage #R&gt; 1 Rivière à l&#39;Orme AAO-0.0 #R&gt; 2 Rivière à l&#39;Orme AAO-1.5P1 #R&gt; 3 Rivière à l&#39;Orme AAO-2.0P4 #R&gt; 4 Rivière à l&#39;Orme AAO-3.3P6 #R&gt; 5 Rivière à l&#39;Orme AAO-3.5 #R&gt; 6 Rivière à l&#39;Orme AAO-3.6 #R&gt; Localisation #R&gt; 1 Pierrefonds, boul. Gouin O, 40m au nord de la rue de l&#39;Anse à l&#39;Orme, exutoire au lac des Deux Montagnes. #R&gt; 2 Pierrefonds, N ponceau boul.Gouin, 1500m en amont exutoire, branche provenant de l&#39;est. #R&gt; 3 Ste-A.-de-Bellevue, branche drainant secteur ouest, 140m à l&#39;est de la rue Leslie Dowker. #R&gt; 4 Kirkland, 60m au sud de l&#39;intersection des rues de l&#39;Anse à l&#39;Orme et de Timberley trail, derrière le dépôt à neige. #R&gt; 5 Sainte-Anne-de-Bellevue, 10m au nord du ch. Ste-Marie, 200m à l&#39;ouest du ch. Anse à l&#39;Orme. #R&gt; 6 Beaconsfield, 250m à l&#39;est de la rue Lee et 25m au sud de l&#39;autoroute 40, en amont du pluvial. #R&gt; Administration Activité geometry #R&gt; 1 Pierrefonds-Roxboro Actif POINT (-73.93704 45.45022) #R&gt; 2 Pierrefonds-Roxboro Inactif POINT (-73.91931 45.44744) #R&gt; 3 Sainte-Anne-de-Bellevue Inactif POINT (-73.91535 45.44288) #R&gt; 4 Kirkland Actif POINT (-73.90147 45.43689) #R&gt; 5 Sainte-Anne-de-Bellevue Actif POINT (-73.90144 45.43566) #R&gt; 6 Baie d&#39;Urfé Actif POINT (-73.9012 45.43462) As you can see, we now have a MULTIPOINT geometry, and the spatial information is now stored in a simple feature list-column (sfc). The other columns contain all the attributes related to the sample points. The default plot of a simple features object is a multi-facet of all attributes. plot(pts_sf) As you can see, instead of creating a single map, as with sp object, the default plot of sf object creates multiple maps, one for each attribute, which can sometimes be useful for exploring the spatial distribution of different variables. 4.2.2 Export your points in a Shapefile We can write a simple features object to a file (e.g. a shapefile) using the st_write() function in sf, which needs at least two arguments, the object and a filename: st_write(pts_sf, &quot;data/pts_sf.shp&quot;, delete_dsn = TRUE) #R&gt; Warning in abbreviate(fld_names, minlength = 7): abbreviate used with non-ASCII #R&gt; chars #R&gt; Warning in abbreviate_shapefile_names(obj): Field names abbreviated for ESRI #R&gt; Shapefile driver #R&gt; Deleting source `data/pts_sf.shp&#39; using driver `ESRI Shapefile&#39; #R&gt; Writing layer `pts_sf&#39; to data source `data/pts_sf.shp&#39; using driver `ESRI Shapefile&#39; #R&gt; Writing 66 features with 5 fields and geometry type Point. Note that st_write() selected one driver base on the file extension provided. The driver can also be made explicit using the driver argument like so: st_write(pts_sf, \"import/pts_sf.shp\", driver = \"ESRI Shapefile\"). Last but not least, in order to have details about drivers available, have a look at the data frame st_drivers() returns. "],["import-shapefile-data.html", "4.3 Import Shapefile data", " 4.3 Import Shapefile data The shapefile contains polygons delimiting the woods of the Montreal agglomeration and information about the forest composition (found here). # Download shapefile from web page in your working directory if (!file.exists(&quot;data/bois.dbf&quot;)) { download.file(&quot;https://data.montreal.ca/dataset/29791562-f050-401e-b405-5c1fbf427f65/resource/9fa20d3a-5dee-43d6-9bc9-5d86fe225e16/download/bois.zip&quot;, destfile = &quot;bois.zip&quot;) unzip(&quot;bois.zip&quot;, exdir = &quot;data&quot;) unlink(&quot;bois.zip&quot;) } # Read shapefile in R bois &lt;- st_read(dsn = &quot;data&quot;, layer = &quot;bois&quot;) #R&gt; Reading layer `bois&#39; from data source `/home/runner/work/rInSpace/rInSpace/data&#39; using driver `ESRI Shapefile&#39; #R&gt; Simple feature collection with 2716 features and 4 fields #R&gt; Geometry type: MULTIPOLYGON #R&gt; Dimension: XY #R&gt; Bounding box: xmin: -73.97557 ymin: 45.40957 xmax: -73.48204 ymax: 45.69943 #R&gt; Geodetic CRS: WGS 84 head(bois) #R&gt; Simple feature collection with 6 features and 4 fields #R&gt; Geometry type: MULTIPOLYGON #R&gt; Dimension: XY #R&gt; Bounding box: xmin: -73.86056 ymin: 45.43293 xmax: -73.49655 ymax: 45.69584 #R&gt; Geodetic CRS: WGS 84 #R&gt; OBJECTID GR_ESSENC Shape_Leng Shape_Area geometry #R&gt; 1 2 Feuillus 515.4464 7199.995 MULTIPOLYGON (((-73.49961 4... #R&gt; 2 3 Feuillus 364.7666 8354.159 MULTIPOLYGON (((-73.51461 4... #R&gt; 3 5 Feuillus 134.2015 1139.293 MULTIPOLYGON (((-73.56527 4... #R&gt; 4 6 Feuillus 336.2568 4222.548 MULTIPOLYGON (((-73.4967 45... #R&gt; 5 8 Feuillus 510.9489 5168.669 MULTIPOLYGON (((-73.85932 4... #R&gt; 6 9 Feuillus 605.2992 10936.294 MULTIPOLYGON (((-73.85413 4... The bois dataset has been turned into a MULTIPOLYGON object and has the same CRS (EPSG: 4326) than the sample points we have manipulated above. This allows us to work directly with the two objects otherwise we should have transformed one dataset using the CRS of the other. To plot only the geometry and not all attributes, we retrieve the geometry list-column using st_geometry(): plot(st_geometry(bois)) To plot the polygons with a thematic color scale according to one attribute of interest, we actually subset the object (here we use the name of the column): plot(bois[&quot;Shape_Area&quot;]) "],["import-geojson-file.html", "4.4 Import GeoJSON file", " 4.4 Import GeoJSON file This GeoJSON dataset contains watercourses (stream, river) and main ditches of the Montreal agglomeration (available here). Hence, it is a MULTILINE object. # Download shapefile from web page in your working directory if (!file.exists(&quot;data/courseau.geojson&quot;)) { download.file(&quot;https://data.montreal.ca/dataset/c128aff5-325c-4599-ab66-1c9d0b3abc94/resource/0f64976e-19c1-4d29-bcc5-4b663a392617/download/courseau.geojson&quot;, destfile = &quot;data/courseau.geojson&quot;) } # For GeoJSON, dsn may be the character string holding the geojson data courseau &lt;- st_read(dsn = &quot;data/courseau.geojson&quot;) #R&gt; Reading layer `courseau&#39; from data source #R&gt; `/home/runner/work/rInSpace/rInSpace/data/courseau.geojson&#39; #R&gt; using driver `GeoJSON&#39; #R&gt; Simple feature collection with 1306 features and 5 fields #R&gt; Geometry type: MULTILINESTRING #R&gt; Dimension: XY #R&gt; Bounding box: xmin: -73.97268 ymin: 45.41593 xmax: -73.4975 ymax: 45.69939 #R&gt; Geodetic CRS: WGS 84 head(courseau) #R&gt; Simple feature collection with 6 features and 5 fields #R&gt; Geometry type: MULTILINESTRING #R&gt; Dimension: XY #R&gt; Bounding box: xmin: -73.9206 ymin: 45.42815 xmax: -73.9066 ymax: 45.47614 #R&gt; Geodetic CRS: WGS 84 #R&gt; OBJECTID_1 NOM TYPE Shape_Le_1 NuméroRui #R&gt; 1 1 rivière à l&#39;Orme rivière 177.95299 &lt;NA&gt; #R&gt; 2 2 rivière à l&#39;Orme rivière 128.51146 &lt;NA&gt; #R&gt; 3 3 &lt;NA&gt; fossé 172.42988 &lt;NA&gt; #R&gt; 4 4 rivière à l&#39;Orme rivière 216.66838 &lt;NA&gt; #R&gt; 5 8 &lt;NA&gt; fossé 540.29539 &lt;NA&gt; #R&gt; 6 9 &lt;NA&gt; ruisseau 97.66412 &lt;NA&gt; #R&gt; geometry #R&gt; 1 MULTILINESTRING ((-73.9107 ... #R&gt; 2 MULTILINESTRING ((-73.90824... #R&gt; 3 MULTILINESTRING ((-73.90667... #R&gt; 4 MULTILINESTRING ((-73.91472... #R&gt; 5 MULTILINESTRING ((-73.91029... #R&gt; 6 MULTILINESTRING ((-73.9206 ... plot(st_geometry(courseau)) "],["import-raster-data.html", "4.5 Import raster data", " 4.5 Import raster data We now import raster data as a .tif file file. Here we chose the data for Rouville in 2015 from the collection of tif files representing the canopy index computed by the Montreal Metropolitain Community (CMM) from an NDVI index and an elevation surface model, represents the low vegetation cover, the high vegetation cover of more than 3 meters (the canopy), the low mineral surfaces and the high mineral surfaces more than 3 meters (roof). # Download tif file from web page in your working directory if (!file.exists(&quot;data/550_CLASS_3m.tif&quot;)) { # 87.9Mo # https://observatoire.cmm.qc.ca/produits/donnees-georeferencees/#indice_canopee download.file(&quot;https://observatoire.cmm.qc.ca/documents/geomatique/IndiceCanopee/2015/550_Canopee2015_3m.zip&quot;, destfile = &quot;canopee.zip&quot;) unzip(&quot;canopee.zip&quot;, files = &quot;550_CLASS_3m.tif&quot;, exdir = &quot;data&quot;) unlink(&quot;canopee.zip&quot;) } # Read tif in R using raster # The file named &quot;660_CLASS_3m.tif&quot; contains the canopy index for all the Montreal area, so we can read this file only canopee_mtl &lt;- raster(&quot;data/550_CLASS_3m.tif&quot;) The canopy index raster has values from 1 to 5, has nrow(canopee_mtl) pixels by row and ncol(canopee_mtl) pixels by column. Note that raster uses the proj4string representation of the coordinate reference system. canopee_mtl #R&gt; class : RasterLayer #R&gt; dimensions : 19230, 8688, 167070240 (nrow, ncol, ncell) #R&gt; resolution : 1, 1 (x, y) #R&gt; extent : 322218, 330906, 5024710, 5043940 (xmin, xmax, ymin, ymax) #R&gt; crs : +proj=tmerc +lat_0=0 +lon_0=-73.5 +k=0.9999 +x_0=304800 +y_0=0 +datum=NAD83 +units=m +no_defs #R&gt; source : 550_CLASS_3m.tif #R&gt; names : X550_CLASS_3m Similar to the sf package, raster also provides plot methods for its own classes. plot(canopee_mtl) "],["basic-mapping.html", "Chapter 5 Basic mapping ", " Chapter 5 Basic mapping "],["plot-methods-for-sp-objects.html", "5.1 Plot methods for sp objects", " 5.1 Plot methods for sp objects Let’s first get some data: library(sp) library(sf) library(raster) bel1 &lt;- getData(&quot;GADM&quot;, country = &quot;BEL&quot;, level = 1, path = &quot;data&quot;) #R&gt; Warning in getData(&quot;GADM&quot;, country = &quot;BEL&quot;, level = 1, path = &quot;data&quot;): getData will be removed in a future version of raster #R&gt; . Please use the geodata package instead bel2 &lt;- getData(&quot;GADM&quot;, country = &quot;BEL&quot;, level = 2, path = &quot;data&quot;) #R&gt; Warning in getData(&quot;GADM&quot;, country = &quot;BEL&quot;, level = 2, path = &quot;data&quot;): getData will be removed in a future version of raster #R&gt; . Please use the geodata package instead Quick plot: plot(bel1) Two quick plots: par(mfrow = c(1, 2), mar = c(0, 0, 0, 0)) plot(bel1, col = 1:3) plot(bel2, lty = 2) Slightly customized plots: plot(bel1, col = &quot;grey85&quot;, main = &quot;Belgium&quot;) plot(bel2, lwd = .5, add = TRUE) points(coordinates(bel2), pch = 19, cex = .4) city &lt;- coordinates(bel2)[1, ] text(city[1], city[2], labels = &quot;Bruxelles&quot;, pos = 3, col = &quot;#9728eb&quot;) "],["plot-methods-for-sf-objects.html", "5.2 plot methods for sf objects", " 5.2 plot methods for sf objects Let’s first get two sf object: bel1_sf &lt;- st_as_sf(bel1) bel2_sf &lt;- st_as_sf(bel2) Let’s try a simple plot. plot(bel1_sf) #R&gt; Warning: plotting the first 9 out of 10 attributes; use max.plot = 10 to plot #R&gt; all It actually plots one map per variable and colors the polygon according to the values. To obtain something similar to what is found in sp, an sfc object must be used: plot(st_geometry(bel1_sf), lwd = 1.5, col = &quot;grey85&quot;) # same as : # plot(bel1_sf$geometry, lwd = 1.5, col = &quot;grey85&quot;) plot(st_geometry(bel2_sf), lwd = .5, add = TRUE) "],["plot-methods-for-raster-objects.html", "5.3 plot methods for raster objects", " 5.3 plot methods for raster objects Let’s get a raster layer of altitude in Belgium using again getData(). alt &lt;- getData(&quot;alt&quot;, country = &quot;Belgium&quot;, path = &quot;data&quot;) #R&gt; Warning in getData(&quot;alt&quot;, country = &quot;Belgium&quot;, path = &quot;data&quot;): getData will be removed in a future version of raster #R&gt; . Please use the geodata package instead plot(alt) We can also add different layers of information on this maps: plot(alt) contour(alt, add = TRUE) Or reclassify and change the color palette: # Assign color to a object myCol &lt;- terrain.colors(3) plot(alt, breaks = c(0, 200, 400, 700), col = myCol, main = &quot;Altitude map of Belgium&quot;) "],["plotting-together-sf-and-raster-objects.html", "5.4 plotting together sf and raster objects", " 5.4 plotting together sf and raster objects # Create a new color palette library(RColorBrewer) myPal &lt;- brewer.pal(n = 9, name = &quot;Greens&quot;) # Plot the altitude raster plot(alt, col = myPal, xlab = &quot;Longitude&quot;, ylab = &quot;Latitude&quot;) # Add Belgium boundary map plot(st_geometry(bel2_sf), add = TRUE) # Add a point at the centroid of Bruxelles brux &lt;- bel2_sf[bel2_sf$NAME_1 == &quot;Bruxelles&quot;,] plot(st_geometry(st_centroid(brux)), pch = 20, add = TRUE) #R&gt; Warning in st_centroid.sf(brux): st_centroid assumes attributes are constant #R&gt; over geometries of x # Add a label for Bruxelles on the map text(st_coordinates(st_centroid(brux)), labels = &quot;Bruxelles&quot;, pos = 3, col = &quot;#9728eb&quot;) #R&gt; Warning in st_centroid.sf(brux): st_centroid assumes attributes are constant #R&gt; over geometries of x "],["package-mapview.html", "5.5 Package mapview", " 5.5 Package mapview library(mapview) mapview(bel1)@map "],["attribute-manipulations.html", "Chapter 6 Attribute manipulations ", " Chapter 6 Attribute manipulations "],["spatial-objects-attributes-manipulations.html", "6.1 Spatial objects attributes manipulations", " 6.1 Spatial objects attributes manipulations Now that we know how to import and transform different classes of spatial objects in R, we can start manipulating their attributes. In this post, we will make a brief overview of some useful basic manipulations that we can perform on spatial object attributes. By no means are those examples exhaustive, but they constitute common manipulations that are made with spatial objects. 6.1.1 Vector objects For this part, we discuss how to manipulate attributes of objects from the sf package. sf objects have the advantage of being structured like data frames, making their manipulations more intuitive than for objects of class sp. However, if the structure of sp objects is well understood, then the same principles will mostly apply. Let’s begin by creating an sf points object as seen in the post on Spatial objects in R mydata &lt;- data.frame( id = 1:20, long = -82 + 2 * runif(20), lat = 42 + 2 * runif(20), var1 = rnorm(20), var2 = 10 * runif(20) ) library(sf) spatData &lt;- st_as_sf(mydata, coords = c(&quot;long&quot;, &quot;lat&quot;), crs = &quot;+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs +towgs84=0,0,0&quot; ) knitr::kable(head(spatData)) id var1 var2 geometry 1 -0.2656208 4.759596 POINT (-81.49872 42.14625) 2 -0.4473916 1.959090 POINT (-81.90416 43.27473) 3 0.5489937 9.644724 POINT (-80.34889 43.69822) 4 0.0284773 4.680517 POINT (-80.50904 43.53668) 5 -0.0961527 4.989629 POINT (-81.23522 43.63335) 6 -1.1786894 8.523099 POINT (-81.90933 42.20106) plot(spatData) 6.1.2 Adding and removing attributes The object we currently have has to variables var1 and var2. Additional attributes can quickly be added to the attributes table of our objects. spatData$var3 &lt;- runif(20) spatData$var4 &lt;- spatData$var1 * spatData$var2 knitr::kable(head(spatData)) id var1 var2 geometry var3 var4 1 -0.2656208 4.759596 POINT (-81.49872 42.14625) 0.8109781 -1.2642476 2 -0.4473916 1.959090 POINT (-81.90416 43.27473) 0.7204655 -0.8764803 3 0.5489937 9.644724 POINT (-80.34889 43.69822) 0.5373404 5.2948924 4 0.0284773 4.680517 POINT (-80.50904 43.53668) 0.8825313 0.1332883 5 -0.0961527 4.989629 POINT (-81.23522 43.63335) 0.5776756 -0.4797662 6 -1.1786894 8.523099 POINT (-81.90933 42.20106) 0.4965744 -10.0460866 Similarly, unwanted columns can be removed. spatData$var3 &lt;- spatData$var4 &lt;- NULL knitr::kable(head(spatData)) id var1 var2 geometry 1 -0.2656208 4.759596 POINT (-81.49872 42.14625) 2 -0.4473916 1.959090 POINT (-81.90416 43.27473) 3 0.5489937 9.644724 POINT (-80.34889 43.69822) 4 0.0284773 4.680517 POINT (-80.50904 43.53668) 5 -0.0961527 4.989629 POINT (-81.23522 43.63335) 6 -1.1786894 8.523099 POINT (-81.90933 42.20106) However, if you have a very big dataset, you may want to remove columns without having to write all column names manually! You could do this based on the names of the columns you wish to remove or, alternatively, on the names of the attributes you wish to keep. # Remove last 20 attributes for (i in 1:5) spatData &lt;- cbind(spatData, varSup = runif(20)) knitr::kable(head(spatData)) id var1 var2 varSup varSup.1 varSup.2 varSup.3 varSup.4 geometry 1 -0.2656208 4.759596 0.9534384 0.6138915 0.1015347 0.5420090 0.6238369 POINT (-81.49872 42.14625) 2 -0.4473916 1.959090 0.8681574 0.4294649 0.4743601 0.2269843 0.8081788 POINT (-81.90416 43.27473) 3 0.5489937 9.644724 0.1361151 0.7992288 0.8391657 0.5569911 0.6493939 POINT (-80.34889 43.69822) 4 0.0284773 4.680517 0.4525283 0.4184388 0.7522447 0.8993869 0.2867850 POINT (-80.50904 43.53668) 5 -0.0961527 4.989629 0.3083761 0.5784799 0.4390189 0.4630437 0.9403453 POINT (-81.23522 43.63335) 6 -1.1786894 8.523099 0.4567769 0.5681770 0.2781423 0.2046933 0.9574098 POINT (-81.90933 42.20106) rem &lt;- colnames(spatData)[4:8] spatData &lt;- spatData[, !colnames(spatData) %in% rem] knitr::kable(head(spatData)) id var1 var2 geometry 1 -0.2656208 4.759596 POINT (-81.49872 42.14625) 2 -0.4473916 1.959090 POINT (-81.90416 43.27473) 3 0.5489937 9.644724 POINT (-80.34889 43.69822) 4 0.0284773 4.680517 POINT (-80.50904 43.53668) 5 -0.0961527 4.989629 POINT (-81.23522 43.63335) 6 -1.1786894 8.523099 POINT (-81.90933 42.20106) # Keep id, var1 and var2 for (i in 1:5) spatData &lt;- cbind(spatData, varSup = runif(20)) knitr::kable(head(spatData)) id var1 var2 varSup varSup.1 varSup.2 varSup.3 varSup.4 geometry 1 -0.2656208 4.759596 0.7449004 0.0452048 0.8988959 0.0168985 0.2944407 POINT (-81.49872 42.14625) 2 -0.4473916 1.959090 0.0900476 0.8871131 0.1598538 0.2328176 0.4268325 POINT (-81.90416 43.27473) 3 0.5489937 9.644724 0.5445201 0.2484915 0.7909352 0.3587498 0.4109497 POINT (-80.34889 43.69822) 4 0.0284773 4.680517 0.6810730 0.7645665 0.9036288 0.4662961 0.3269100 POINT (-80.50904 43.53668) 5 -0.0961527 4.989629 0.4125643 0.9801848 0.2356249 0.9420042 0.5674170 POINT (-81.23522 43.63335) 6 -1.1786894 8.523099 0.8083331 0.2663551 0.8119234 0.2049022 0.4381835 POINT (-81.90933 42.20106) keep &lt;- c(&quot;id&quot;, &quot;var1&quot;, &quot;var2&quot;) spatData &lt;- spatData[, keep] knitr::kable(head(spatData)) id var1 var2 geometry 1 -0.2656208 4.759596 POINT (-81.49872 42.14625) 2 -0.4473916 1.959090 POINT (-81.90416 43.27473) 3 0.5489937 9.644724 POINT (-80.34889 43.69822) 4 0.0284773 4.680517 POINT (-80.50904 43.53668) 5 -0.0961527 4.989629 POINT (-81.23522 43.63335) 6 -1.1786894 8.523099 POINT (-81.90933 42.20106) 6.1.3 Subsets You may also wish to subset your object based on certain attribute values. We will begin by adding some factorial attributes to our spatial object to discuss this in more detail. spatData$fact1 &lt;- paste0(&quot;a&quot;, 1:2) # Create factor with 2 levels spatData$fact2 &lt;- paste0(&quot;b&quot;, 1:5) # Create factor with 5 levels knitr::kable(head(spatData)) id var1 var2 geometry fact1 fact2 1 -0.2656208 4.759596 POINT (-81.49872 42.14625) a1 b1 2 -0.4473916 1.959090 POINT (-81.90416 43.27473) a2 b2 3 0.5489937 9.644724 POINT (-80.34889 43.69822) a1 b3 4 0.0284773 4.680517 POINT (-80.50904 43.53668) a2 b4 5 -0.0961527 4.989629 POINT (-81.23522 43.63335) a1 b5 6 -1.1786894 8.523099 POINT (-81.90933 42.20106) a2 b1 The most simple way to subset an attributes table would be to manually select the rows that we wish to view. In this instance, let’s say we only wish to use the first 10 rows of our data. selectID &lt;- 1:10 plot(spatData$geometry, col = &quot;#00000055&quot;, pch = 20, cex = 1.25, main = &quot;&quot;) plot(spatData$geometry[selectID], col = &quot;#000000&quot;, add = TRUE, pch = 1, cex = 2, lwd = 2) However, subsets based on certain criteria, e.g. all values greater to or equal to 0, can be much more efficient to create subsets. These are conditional statements and there is a vast body of material available discussing them, so we will only present a few examples and invite you to consult other resources like StackOverflow for more specific questions. # Select all values for var1 greater to or equal to 0 selectID &lt;- spatData$var1 &gt;= 0 plot(spatData$geometry, col = &quot;#00000055&quot;, pch = 20, cex = 1.25, main = &quot;&quot;) plot(spatData$geometry[selectID], col = &quot;#000000&quot;, add = T, pch = 1, cex = 2, lwd = 2) # var1 smaller than 0 and var2 higher than 5 selectID &lt;- spatData$var1 &lt; 0 &amp; spatData$var2 &lt; 5 plot(spatData$geometry, col = &quot;#00000055&quot;, pch = 20, cex = 1.25, main = &quot;&quot;) plot(spatData$geometry[selectID], col = &quot;#000000&quot;, add = T, pch = 1, cex = 2, lwd = 2) # fact1 equal to a1 selectID &lt;- spatData$fact1 == &quot;a1&quot; plot(spatData$geometry, col = &quot;#00000055&quot;, pch = 20, cex = 1.25, main = &quot;&quot;) plot(spatData$geometry[selectID], col = &quot;#000000&quot;, add = T, pch = 1, cex = 2, lwd = 2) # fact1 equal to a1 or var1 greater than 0 selectID &lt;- spatData$fact1 == &quot;a1&quot; | spatData$var1 &gt; 0 plot(spatData$geometry, col = &quot;#00000055&quot;, pch = 20, cex = 1.25, main = &quot;&quot;) plot(spatData$geometry[selectID], col = &quot;#000000&quot;, add = T, pch = 1, cex = 2, lwd = 2) # fact2 equal to b3 or b4 selectID &lt;- spatData$fact2 %in% c(&quot;b3&quot;, &quot;b4&quot;) plot(spatData$geometry, col = &quot;#00000055&quot;, pch = 20, cex = 1.25, main = &quot;&quot;) plot(spatData$geometry[selectID], col = &quot;#000000&quot;, add = T, pch = 1, cex = 2, lwd = 2) 6.1.4 Join Joining tables based on their shared id is another common manipulation. This can be quickly accomplished using the left_join function from the dplyr package. # Create data.frame with id field similar to that in the spatial object joinData &lt;- data.frame(id = seq(1, 20, by = 2), var3 = rnorm(10)) # Join with attributes table of spatial object library(dplyr) #R&gt; #R&gt; Attaching package: &#39;dplyr&#39; #R&gt; The following objects are masked from &#39;package:raster&#39;: #R&gt; #R&gt; intersect, select, union #R&gt; The following objects are masked from &#39;package:stats&#39;: #R&gt; #R&gt; filter, lag #R&gt; The following objects are masked from &#39;package:base&#39;: #R&gt; #R&gt; intersect, setdiff, setequal, union spatData &lt;- left_join(spatData, joinData) #R&gt; Joining with `by = join_by(id)` knitr::kable(head(spatData)) id var1 var2 fact1 fact2 var3 geometry 1 -0.2656208 4.759596 a1 b1 -0.8490988 POINT (-81.49872 42.14625) 2 -0.4473916 1.959090 a2 b2 NA POINT (-81.90416 43.27473) 3 0.5489937 9.644724 a1 b3 -1.0932612 POINT (-80.34889 43.69822) 4 0.0284773 4.680517 a2 b4 NA POINT (-80.50904 43.53668) 5 -0.0961527 4.989629 a1 b5 -1.0502298 POINT (-81.23522 43.63335) 6 -1.1786894 8.523099 a2 b1 NA POINT (-81.90933 42.20106) 6.1.5 Aggregate Information contained in a table can also be used to aggregate aggData &lt;- aggregate(spatData[&#39;var1&#39;], by = list(spatData$fact1), FUN = sum) knitr::kable(head(aggData)) Group.1 var1 geometry a1 2.164414 MULTIPOINT ((-81.78574 43.2… a2 -2.856789 MULTIPOINT ((-81.90933 42.2… plot(aggData, cex = abs(aggData$var1)) "],["geometry-manipulation.html", "Chapter 7 Geometry manipulation", " Chapter 7 Geometry manipulation To manipulate geometries, there are few options. For spatial objects defined with sp, there is a specific package to manipulate vector objects: rgeos. The equivalent of most common functions in sp are found in sf. Finally, there are a set of interesting functions in raster to handle the manipulation of rasters with vector objects. Let’s first load the packages required and download a simple shapefile of Belgium. library(sp) library(sf) library(rgeos) library(raster) bel2 &lt;- getData(name = &quot;GADM&quot;, country = &quot;BEL&quot;, path = &quot;data&quot;, level = 2) #R&gt; Warning in getData(name = &quot;GADM&quot;, country = &quot;BEL&quot;, path = &quot;data&quot;, level = 2): getData will be removed in a future version of raster #R&gt; . Please use the geodata package instead plot(bel2) text(bel2, 1:11) "],["sp-objects.html", "7.1 sp objects", " 7.1 sp objects 7.1.1 Subset A quick subset: ## Create a subset (A sub-shapefile) slc &lt;- 8:11 bel_slc &lt;- bel2[slc, ] class(bel_slc) #R&gt; [1] &quot;SpatialPolygonsDataFrame&quot; #R&gt; attr(,&quot;package&quot;) #R&gt; [1] &quot;sp&quot; Let’s plot our selection: plot(bel_slc) 7.1.2 Unions Let’s do the union of a selection of spatial polygons: bel_south &lt;- gUnionCascaded(bel_slc) bel_north &lt;- gUnionCascaded(bel2[-slc, ]) bel_one &lt;- gUnionCascaded(bel2) par(mfrow = c(1, 3), mar = c(1, 1, 1, 1)) plot(bel_south) plot(bel_north) plot(bel_one) Let’s combine them on one plot: plot(bel2, lwd = .1) plot(bel_south, add = TRUE, col = 2) plot(bel_north, add = TRUE, col = 4) plot(bel2, lwd = .5, add = TRUE) plot(bel_one, lwd = 2, add = TRUE, border = &quot;grey55&quot;) 7.1.3 Buffers Buffer must be done on planar coordinates. plot(bel2) bufs &lt;- gBuffer(bel_south, width = 0.4) #R&gt; Warning: GEOS support is provided by the sf and terra packages among others #R&gt; Warning in gBuffer(bel_south, width = 0.4): Spatial object is not projected; #R&gt; GEOS expects planar coordinates bufn &lt;- gBuffer(bel_north, width = 0.1) #R&gt; Warning: GEOS support is provided by the sf and terra packages among others #R&gt; Warning in gBuffer(bel_north, width = 0.1): Spatial object is not projected; #R&gt; GEOS expects planar coordinates plot(bufs, add = TRUE, lwd = 2, lty = 2) plot(bufn, add = TRUE, lwd = 3) 7.1.4 Intersections Intersections between bel_south and bel_north: par(mfrow = c(1, 2)) plot(bel_one) plot(gIntersection(bel_south, bel_north), col = 5, add = TRUE, lwd = 2) #R&gt; Warning: GEOS support is provided by the sf and terra packages among others plot(bel_one) plot(gIntersection(bufs, bufn), col = 5, add = TRUE, lwd = 2) #R&gt; Warning: GEOS support is provided by the sf and terra packages among others 7.1.5 Differences bel_diff &lt;- gDifference(bufs, bufn) #R&gt; Warning: GEOS support is provided by the sf and terra packages among others plot(bel_one) plot(bel_diff, add = TRUE, lwd = 2, lty = 3, col = 2) plot(bel_south, add = TRUE, col = 2) "],["overlays.html", "7.2 Overlays", " 7.2 Overlays One very useful tool is the over() function which provides a consistent spatial overlay. For instance, here, I create a set of random points and look which one are in bel2, bel_north and bel_south: pts &lt;- SpatialPoints( coords = cbind( runif(50, bel2@bbox[1, 1], bel2@bbox[1, 2]), runif(50, bel2@bbox[2, 1], bel2@bbox[2, 2]) ), proj4string = bel2@proj4string ) # Make a SpatialPolygons bel2_geom &lt;- SpatialPolygons(bel2@polygons, proj4string = bel2@proj4string) # plots plot(bel2_geom) points(pts, col = is.na(over(pts, bel2_geom)) + 2, pch = 19) "],["sf-objects.html", "7.3 sf objects", " 7.3 sf objects Have a look at the dedicated vignette: https://cran.r-project.org/web/packages/sf/vignettes/sf3.html "],["raster-objects.html", "7.4 raster objects", " 7.4 raster objects Let’s now download a simple raster of elevation using getData(). bel_elv &lt;- getData(name = &quot;alt&quot;, country = &quot;BEL&quot;, path = &quot;data&quot;, level = 2) #R&gt; Warning in getData(name = &quot;alt&quot;, country = &quot;BEL&quot;, path = &quot;data&quot;, level = 2): getData will be removed in a future version of raster #R&gt; . Please use the geodata package instead plot(bel_elv) 7.4.1 Extract values Note that extract() is in raster val_south &lt;- extract(bel_elv, bel_south) val_north &lt;- extract(bel_elv, bel_north) # par(mfrow = c(1,2)) hist(val_south[[1]]) hist(val_north[[1]]) 7.4.2 Mask elv_south &lt;- rasterize(bel_south, bel_elv, mask = TRUE) elv_north &lt;- rasterize(bel_north, bel_elv, mask = TRUE) par(mfrow = c(1,2)) plot(elv_south) plot(elv_north) "],["r-data-resources.html", "Chapter 8 R data resources", " Chapter 8 R data resources With the R community as vibrant and dynamic as it is, there are an increasingly high number of online data resources readily available to users through simple lines of command. The best hub of R packages making online data available to R users is actively developed by the rOpenSci group. This non-profit organization aims at foster[ing] a culture that values open and reproducible research using shared data and reusable software. Data access tools is however not limited to this group and a quick search reveals the wealth of data not available to R users. In this post, we will explore some valuable geospatial resources that are accessible using R. We do not mean to provide a thorough review of each resource, but rather provide a list of valuable resources for geospatial data in R and invite readers to consult specific package material for further detail. "],["environmental-data.html", "8.1 Environmental data", " 8.1 Environmental data 8.1.1 Abiotic data marmap raster rnoaa rWBclimate sdmpredictors 8.1.2 Biotic data rgbif robis spocc 8.1.3 Base maps ggmap mregions osmdata raster rnaturalearth "],["custom-mapping.html", "Chapter 9 Custom mapping ", " Chapter 9 Custom mapping "],["creating-a-thematic-map.html", "9.1 Creating a thematic map", " 9.1 Creating a thematic map In this post, we go through all the steps required to produce a complete good-looking map. We will see how to add a title, a legend, a scale, axis and a North arrow and choose a good color palette. To do so, we will use the Quebec province as our sampled area. So, first, we import 2 vector layers readily available in R, the Canadian provincial boundaries and USA country boundary. library(sf) library(raster) can1 &lt;- getData(&quot;GADM&quot;, country = &quot;CAN&quot;, level = 1, path = &quot;data&quot;) #R&gt; Warning in getData(&quot;GADM&quot;, country = &quot;CAN&quot;, level = 1, path = &quot;data&quot;): getData will be removed in a future version of raster #R&gt; . Please use the geodata package instead usa0 &lt;- getData(&quot;GADM&quot;, country = &quot;USA&quot;, level = 0, path = &quot;data&quot;) #R&gt; Warning in getData(&quot;GADM&quot;, country = &quot;USA&quot;, level = 0, path = &quot;data&quot;): getData will be removed in a future version of raster #R&gt; . Please use the geodata package instead Transform to sf objects to facilitate manipulation can1_sf &lt;- st_as_sf(can1) usa0_sf &lt;- st_as_sf(usa0) Retrieve Quebec polygon and surrounding provinces qc &lt;- can1_sf[can1_sf$NAME_1 == &quot;Québec&quot;, ] qc_neigh &lt;- can1_sf[can1_sf$NAME_1 %in% c(&quot;Québec&quot;, &quot;Ontario&quot;, &quot;Nova Scotia&quot;, &quot;New Brunswick&quot;, &quot;Newfoundland and Labrador&quot;), ] It would take a while to plot because there is a lot of unnecessary details, so we can simplify the shape of the polygons using st_simplify(). usa0_simple &lt;- st_simplify(usa0_sf, dTolerance = .05, preserveTopology = FALSE) #R&gt; Warning in st_simplify.sfc(st_geometry(x), preserveTopology, dTolerance): #R&gt; argument preserveTopology cannot be set to FALSE when working with ellipsoidal #R&gt; coordinates since the algorithm behind st_simplify always preserves topological #R&gt; relationships qc_simple &lt;- st_simplify(qc, dTolerance = .01, preserveTopology = FALSE) #R&gt; Warning in st_simplify.sfc(st_geometry(x), preserveTopology, dTolerance): #R&gt; argument preserveTopology cannot be set to FALSE when working with ellipsoidal #R&gt; coordinates since the algorithm behind st_simplify always preserves topological #R&gt; relationships qc_neigh_simple &lt;- st_simplify(qc_neigh, dTolerance = .01, preserveTopology = FALSE) #R&gt; Warning in st_simplify.sfc(st_geometry(x), preserveTopology, dTolerance): #R&gt; argument preserveTopology cannot be set to FALSE when working with ellipsoidal #R&gt; coordinates since the algorithm behind st_simplify always preserves topological #R&gt; relationships The warning stating that st_simplify does not correctly simplify longitude/latitude data and it should be in decimal degrees. It’s important in some spatial operations involving distances, but we can ignore it for the purpose of mapping. Let’s look at what we have: plot(st_geometry(qc_simple), col = &quot;grey85&quot;) plot(st_geometry(qc_neigh_simple), col = &quot;grey45&quot;, add = TRUE) plot(st_geometry(usa0_simple), col = &quot;grey25&quot;, add = TRUE) Let’s say we sampled vegetation in 100 plots in Quebec; we now want to plot them with points proportional to their species richness. We will now create a data frame containing coordinates and random values from 5 to 50. # Sample random points from our study area sample_pts &lt;- st_sample(x = qc_simple, size = 100) # Create an attribute of fake species richness sample_richness &lt;- sample(x = 5:50, size = 100, replace = TRUE) "],["add-a-temperature-raster.html", "9.2 Add a temperature raster", " 9.2 Add a temperature raster If we were interested in the latitudinal temperature gradient, we could add a raster of mean temperature as a background to our map. We will use a low resolution so it does not take to long. temp &lt;- getData(&quot;worldclim&quot;, var = &quot;tmean&quot;, res = 10, path = &quot;data&quot;) #R&gt; Warning in getData(&quot;worldclim&quot;, var = &quot;tmean&quot;, res = 10, path = &quot;data&quot;): getData will be removed in a future version of raster #R&gt; . Please use the geodata package instead # Change projection to match with the polygons temp &lt;- projectRaster(temp, crs = st_crs(qc_simple)$proj4string) #R&gt; Warning in projectRaster(temp, crs = st_crs(qc_simple)$proj4string): input and #R&gt; ouput crs are the same # There are 12 layers in this raster. # Keep only the layer for June temperature: tmean6 and divide by 10 (because Worldclim temperature data are in °C * 10) temp6 &lt;- temp$tmean6 / 10 "],["crop-and-mask-the-temperature-raster-using-quebec-boundary..html", "9.3 Crop and mask the temperature raster using quebec boundary.", " 9.3 Crop and mask the temperature raster using quebec boundary. First, crop() will decrease the extent of the raster using the extent of another spatial object and mask() keeps the raster values only in the area of interest and set the rest to NA. Because crop() from raster expects a sp object we will use transform the polygon first. temp_crop &lt;- crop(temp6, as(qc_simple, &quot;Spatial&quot;)) temp_mask &lt;- mask(temp_crop, qc_simple) "],["creating-a-simple-layout.html", "9.4 Creating a simple layout", " 9.4 Creating a simple layout my.layout &lt;- layout(matrix(1:2, 2), heights = c(1, .14)) layout.show(my.layout) – mar controls the margins of the plot area; – xaxs and yaxs controls axis style. library(RColorBrewer) layout(matrix(1:2, 2), heights = c(1, .16)) par(las = 1, xaxs = &quot;i&quot;, yaxs = &quot;i&quot;, mar = rep(c(2.5, 3), 2)) myblu &lt;- &quot;#6da6c2&quot; mygre &lt;- &quot;grey50&quot; mypal &lt;- colorRampPalette(rev(brewer.pal(11, &quot;RdYlBu&quot;)))(124) plot(st_geometry(qc_neigh_simple), graticule = st_crs(qc_simple), # add graticules col = &quot;#b5cfbd&quot;, border = mygre, xlim = c(-82, -56), ylim = c(43, 64) ) plot(st_geometry(usa0_simple), col = &quot;#b5cfbd&quot;, border = mygre, add = TRUE) # Temperature raster image(temp_mask, add = TRUE, col = mypal) # Quebec boundary on top plot(st_geometry(qc_simple), add = TRUE, col = NA, border = &quot;grey15&quot;, lwd = 1.4) # Sample points plot(st_geometry(sample_pts), add = T, pch = 21, bg = &quot;#63636388&quot;, col = &quot;grey15&quot;, lwd = 1.4, cex = sample_richness / 25 ) # Size proportional to richness # Axis axis(1) axis(2, las = 1) axis(3) axis(4, las = 1) box(lwd = 1.2) # Compass rose sp::compassRose(-57, 60) # Legend par(mar = c(3.2, 5, .5, 5), mgp = c(2, .5, 0)) val &lt;- range(values(temp_mask), na.rm = TRUE) image(as.matrix(seq(val[1], val[2], length = 512)), col = mypal, axes = FALSE) axis(1, at = seq(0.001, .999, length = 6), labels = round(seq(val[1], val[2], length = 6), 2)) mtext(side = 1, line = 1.8, text = &quot;Mean annual temperature (°C)&quot;) "],["examples-of-complex-layouts.html", "9.5 Examples of complex layouts", " 9.5 Examples of complex layouts The layout() function can be used to produce simple to very complex layouts for figures. The previous figure was a rather simple example and we will show two other examples from a scientific article that David is currently wrapping up. These examples are simply to help visualizing the fact that as long as you can position elements on a two-dimensional cartesian plane, than you can create whatever visual you may have in mind with R. 9.5.1 Setting data and parameters Let’s begin with getting data! The data for the original figure is inacessible (for now), so we will access marine abiotic data using the sdmpredictors package. The original figure is however show at the end of the post, and the data should become openly available soon. library(sdmpredictors) library(magrittr) #R&gt; #R&gt; Attaching package: &#39;magrittr&#39; #R&gt; The following object is masked from &#39;package:raster&#39;: #R&gt; #R&gt; extract library(MASS) #R&gt; #R&gt; Attaching package: &#39;MASS&#39; #R&gt; The following object is masked from &#39;package:dplyr&#39;: #R&gt; #R&gt; select #R&gt; The following objects are masked from &#39;package:raster&#39;: #R&gt; #R&gt; area, select library(graphicsutils) #R&gt; #R&gt; Attaching package: &#39;graphicsutils&#39; #R&gt; The following object is masked from &#39;package:sp&#39;: #R&gt; #R&gt; compassRose # Extent of area of interest latmax &lt;- 52.01312 latmin &lt;- 45.52399 lonmax &lt;- -55.73636 lonmin &lt;- -71.06333 # Focal, local area xmn &lt;- -67 xmx &lt;- -63 ymn &lt;- 49 ymx &lt;- 51 # Import marine layers layers &lt;- c(&quot;BO_dissox&quot;, &quot;BO_sstmean&quot;) envCov &lt;- sdmpredictors::load_layers(layers, datadir = &quot;data&quot;, rasterstack = TRUE) # Crop and build raster stack envCov &lt;- raster::crop(envCov, raster::extent(lonmin, lonmax, latmin, latmax)) %&gt;% raster::stack() # Visualize data raster::plot(envCov) # For this graph, we will normalize the values values(envCov[[1]]) &lt;- values(envCov[[1]]) / max(values(envCov[[1]]), na.rm = TRUE) values(envCov[[2]]) &lt;- values(envCov[[2]]) / max(values(envCov[[2]]), na.rm = TRUE) We will also need certain elements, such as a custom color palette, for this figure. # Color palette cols &lt;- c( &quot;#f4f4f4&quot;, &quot;#C7CBCE&quot;, &quot;#96A3A3&quot;, &quot;#687677&quot;, &quot;#222D3D&quot;, &quot;#25364A&quot;, &quot;#C77F20&quot;, &quot;#E69831&quot;, &quot;#E3AF16&quot;, &quot;#E4BE29&quot;, &quot;#F2EA8B&quot; ) rbPal &lt;- colorRampPalette(cols) # Custom color bar function colorBar &lt;- function(colRamp, min, max = -min, nticks = 11, ticks = seq(min, max, len = nticks), title = &quot;&quot;, ...) { scale &lt;- (length(colRamp) - 1) / (max - min) plot(c(min, max), c(0, 1), type = &quot;n&quot;, bty = &quot;n&quot;, xaxt = &quot;n&quot;, xlab = &quot;&quot;, yaxt = &quot;n&quot;, ylab = &quot;&quot;, main = title, ...) axis(1, ticks, las = 1, ...) for (i in 1:(length(colRamp) - 1)) { y &lt;- (i - 1) / scale + min rect(y, 0, y + 1 / scale, 10, col = colRamp[i], border = NA) } } 9.5.2 First example Now we can build a more complicated figure worthy of a scientific article. Let’s begin with a first layout example for a complex four panel figure. # Layout mat &lt;- matrix(0, 28, 32) mat[1:12, 1:16] &lt;- 1 mat[15:26, 1:16] &lt;- 2 mat[1:12, 17:32] &lt;- 3 mat[18:28, 17:29] &lt;- 4 mat[15:17, 17:29] &lt;- 5 mat[18:28, 30:32] &lt;- 6 mat[13:14, 6:11] &lt;- 7 mat[27:28, 6:11] &lt;- 8 mat[13:14, 22:27] &lt;- 9 mat[1:2, 15:16] &lt;- 10 mat[15:16, 15:16] &lt;- 11 mat[1:2, 31:32] &lt;- 12 mat[15:16, 31:32] &lt;- 13 layout(mat) layout.show(13) The elements on this complex layout will be drawn sequentially following the order specified in the layout matrix. layout(mat) par(mar = c(2, 2, 2, 2)) # Plot 1 image(envCov[[1]], col = rbPal(100), main = &quot;&quot;, axes = FALSE) # Plot 2 image(envCov[[2]], col = rbPal(100), main = &quot;&quot;, axes = FALSE) # Plot 3 image(envCov[[1]] + envCov[[2]], col = rbPal(100), main = &quot;&quot;, axes = FALSE) # Plot 4 # Select only values that are not == 0 notEmpty &lt;- !is.na(values(envCov[[1]])) # 2D kernel estimation f1 &lt;- kde2d( x = values(envCov[[1]])[notEmpty], y = values(envCov[[2]])[notEmpty], n = 500, # put 500 for final figure lims = c(0, 1, 0, 1) ) par(mar = c(4, 4, 0, 0)) graphicsutils::plot0(c(0, 1)) image(f1, zlim = c(0, max(f1$z)), col = c(&quot;#ffffff&quot;, rbPal(99)), add = T) axis(1, seq(0, 1, 0.1), line = -.25, lwd = 0.5) axis(2, seq(0, 1, 0.1), las = 2, line = -0.5, lwd = 0.5) mtext(&quot;Dissolved oxygen&quot;, 1, line = 2.5, font = 1, cex = 0.8) mtext(&quot;Sea surface temperature&quot;, 2, line = 2.5, font = 1, cex = 0.8) # Plot 5 dens &lt;- density(values(envCov[[1]])[notEmpty], from = 0, to = 1) par(mar = c(0, 4, 0, 0)) graphicsutils::plot0(c(0, 1), c(0, ceiling(max(dens$y)))) polygon(x = c(dens$x, 1), y = c(dens$y, 0), col = cols[5], border = cols[5], lwd = 1) axis(2, c(0, ceiling(max(dens$y))), lwd = 0.5, line = -0.5, las = 2) mtext(&quot;Density&quot;, 2, line = 2.5, font = 1, cex = 0.8) # Plot 6 par(mar = c(4, 0, 0, 0)) dens &lt;- density(values(envCov[[2]])[notEmpty], from = 0, to = 1) graphicsutils::plot0(c(0, ceiling(max(dens$y))), c(0, 1)) polygon(x = c(dens$x, 1), y = c(dens$y, 0), col = cols[5], border = cols[5], lwd = 1) axis(1, c(0, ceiling(max(dens$y))), line = -.25, lwd = 0.5) mtext(&quot;Density&quot;, 1, line = 2.5, font = 1, cex = 0.8) # plot 7 par(mar = c(3, 0, 0, 0)) colorBar(rbPal(100), nticks = 6, min = 0, max = 1, lwd = 0.5) rect(xleft = 0, ybottom = 0, xright = 1, ytop = 1, lwd = 0.5) mtext(&quot;Dissolved oxygen&quot;, 3, line = 0.5, font = 2, cex = 0.8) # plot 8 par(mar = c(3, 0, 0, 0)) colorBar(rbPal(100), nticks = 6, min = 0, max = 1, lwd = 0.5) rect(xleft = 0, ybottom = 0, xright = 1, ytop = 1, lwd = 0.5) mtext(&quot;Sea surface temperature&quot;, 3, line = 0.5, font = 2, cex = 0.8) # plot 9 par(mar = c(3, 0, 0, 0)) colorBar(rbPal(100), nticks = 6, min = 0, max = 2, lwd = 0.5) rect(xleft = 0, ybottom = 0, xright = 2, ytop = 1, lwd = 0.5) mtext(expression(bold(sum(&quot;Oxygen, Temperature&quot;))), 3, line = 0.5, font = 2, cex = 0.8) # plot 10 - panel A par(mar = c(0, 0, 0, 0)) plot0(c(0, 1)) text(x = 0.5, y = 0.5, labels = &quot;A&quot;, font = 2, cex = 1.35) # plot 11 - panel B par(mar = c(0, 0, 0, 0)) plot0(c(0, 1)) text(x = 0.5, y = 0.5, labels = &quot;B&quot;, font = 2, cex = 1.35) # plot 12 - panel C par(mar = c(0, 0, 0, 0)) plot0(c(0, 1)) text(x = 0.5, y = 0.5, labels = &quot;C&quot;, font = 2, cex = 1.35) # plot 13 - panel D par(mar = c(0, 0, 0, 0)) plot0(c(0, 1)) text(x = 0.5, y = 0.5, labels = &quot;D&quot;, font = 2, cex = 1.35) While it may seem complicated, all of these plot calls are make up each element of the graph. Before you say I could do this with photoshop!, keep in mind that with this code, I can now change or update the data at will and recreate the same figure effortlessly. Here is the actual figure that was built using this complex layout, representing hypoxia and demersal fisheries intensity in the St. Lawrence and a comparison of they joint density distribution. 9.5.3 Second example We can now move on to the second example showing that text can also be readily incorporated into a complex figure layout. Once again, this layout has been used to generate a figure used in a scientific paper and soon to be submitted for publication. mat &lt;- matrix(0, 17, 10) # Arrows mat[1:3, 1:2] &lt;- 1 mat[1:3, 9:10] &lt;- 2 mat[15:17, 1:2] &lt;- 3 mat[15:17, 9:10] &lt;- 4 mat[9, 1:2] &lt;- 5 mat[9, 9:10] &lt;- 6 # Boxes mat[4:8, 1:5] &lt;- 7 mat[10:14, 1:5] &lt;- 8 mat[4:8, 6:10] &lt;- 9 mat[10:14, 6:10] &lt;- 10 # Plots mat[1:3, 3:8] &lt;- 11 mat[15:17, 3:8] &lt;- 12 mat[6:7, 2:3] &lt;- 13 mat[12:13, 2:3] &lt;- 14 mat[6:7, 8:9] &lt;- 15 mat[12:13, 8:9] &lt;- 16 # Text mat[5, 2:5] &lt;- 17 mat[11, 2:5] &lt;- 18 mat[5, 6:9] &lt;- 19 mat[11, 6:9] &lt;- 20 mat[6:7, 4:5] &lt;- 21 mat[12:13, 4:5] &lt;- 22 mat[6:7, 6:7] &lt;- 23 mat[12:13, 6:7] &lt;- 24 layout(mat, heights = c(1, 1, 1, .2, .2, 1, 1, .2, .4, .2, .2, 1, 1, .2, 1, 1, 1), widths = c(.2, 1, 1, 1, .5, .5, 1, 1, 1, .2) ) layout.show(24) layout(mat, heights = c(1, 1, 1, .2, .2, 1, 1, .2, .4, .2, .2, 1, 1, .2, 1, 1, 1), widths = c(.2, 1, 1, 1, .5, .5, 1, 1, 1, .2) ) # 1 par(mar = c(0, 0, 0, 0)) plot0(c(0, 1)) lines(x = c(.5, 1), y = c(.5, .5)) lines(x = c(.5, .5), y = c(0, .5)) polygon(x = c(.5, .47, .53, .5), y = c(0, .03, .03, 0), col = &quot;black&quot;) text(x = 1, y = .53, labels = &quot;Local management&quot;, cex = .75, font = 1, adj = c(1, 0)) # 2 par(mar = c(0, 0, 0, 0)) plot0(c(0, 1)) lines(x = c(0, .5), y = c(.5, .5)) lines(x = c(.5, .5), y = c(0, .5)) polygon(x = c(.5, .47, .53, .5), y = c(0, .03, .03, 0), col = &quot;black&quot;) text(x = 0, y = .53, labels = &quot;Regional management&quot;, cex = .75, font = 1, adj = c(0, 0)) # 3 par(mar = c(0, 0, 0, 0)) plot0(c(0, 1)) lines(x = c(.5, 1), y = c(.5, .5)) lines(x = c(.5, .5), y = c(1, .5)) polygon(x = c(1, .93, .93, 1), y = c(.5, .51, .49, .5), col = &quot;black&quot;) # 4 par(mar = c(0, 0, 0, 0)) plot0(c(0, 1)) lines(x = c(0, .5), y = c(.5, .5)) lines(x = c(.5, .5), y = c(1, .5)) polygon(x = c(0, .07, .07, 0), y = c(.5, .51, .49, .5), col = &quot;black&quot;) # 5, 6 for (i in 1:2) { par(mar = c(0, 0, 0, 0)) plot0(c(0, 1)) lines(x = c(.5, .5), y = c(0, 1)) polygon(x = c(.5, .47, .53, .5), y = c(0, .18, .18, 0), col = &quot;black&quot;) } # 7, 8, 9, 10 for (i in 1:4) { par(mar = c(0, 0, 0, 0)) plot0(c(0, 1)) rect(0, 0, 1, 1, border = &quot;black&quot;) } # 11 for (i in 1:2) { par(mar = c(1, 1, 1, 1)) image(envCov[[1]], col = rbPal(100), main = &quot;&quot;, axes = FALSE) rect(xmn, ymn, xmx, ymx, lwd = 1, border = &quot;#00000099&quot;) } # 12 par(mar = c(1, 1, 1, 1)) image(envCov[[1]] + envCov[[2]], col = rbPal(100), main = &quot;&quot;, axes = FALSE) rect(xmn, ymn, xmx, ymx, lwd = 1, border = &quot;#00000099&quot;) # 13, 14 for (i in 1:2) { par(mar = c(1.25, 1.25, 1.25, 1.25)) plot0(x = c(xmn, xmx), y = c(ymn, ymx)) image(envCov[[1]], col = rbPal(100), main = &quot;&quot;, axes = FALSE, add = TRUE) rect(xmn, ymn, xmx, ymx, lwd = 1, border = &quot;#00000099&quot;) } # 15, 16 for (i in 1:2) { par(mar = c(1, 1, 1, 1)) image(envCov[[2]], col = rbPal(100), main = &quot;&quot;, axes = FALSE) } # 17 Title 1 par(mar = c(0, 0, 0, 0)) plot0(c(0, 1)) text(x = 0, y = 1, labels = &quot;Title1 - Year1&quot;, cex = 1, font = 2, adj = c(0, 1)) # 18 Title 2 par(mar = c(0, 0, 0, 0)) plot0(c(0, 1)) text(x = 0, y = 1, labels = &quot;Title1 - Year2&quot;, cex = 1, font = 2, adj = c(0, 1)) # 19 Title 3 par(mar = c(0, 0, 0, 0)) plot0(c(0, 1)) text(x = 1, y = 1, labels = &quot;Title2 - Year1&quot;, cex = 1, font = 2, adj = c(1, 1)) # 20 Title 4 par(mar = c(0, 0, 0, 0)) plot0(c(0, 1)) text(x = 1, y = 1, labels = &quot;Title2 - Year2&quot;, cex = 1, font = 2, adj = c(1, 1)) # 21, 22, 23, 24 for (i in 1:2) { par(mar = c(0.1, 0.1, 0.1, 0.1)) plot0(x = c(0, 1)) text(x = 0, y = .95, &quot;Jurisdiction:&quot;, cex = 0.75, adj = c(0, 1), font = 2) text(x = .05, y = .85, &quot;\\u2022 Municipal&quot;, cex = 0.75, adj = c(0, 1)) text(x = 0, y = .7, &quot;Spatial distribution:&quot;, cex = 0.75, adj = c(0, 1), font = 2) text(x = .05, y = .6, &quot;\\u2022 Local&quot;, cex = 0.75, adj = c(0, 1)) text(x = 0, y = .45, &quot;Data collection protocols:&quot;, cex = 0.75, adj = c(0, 1), font = 2) text(x = .05, y = .35, &quot;\\u2022 Non-standardized&quot;, cex = 0.75, adj = c(0, 1)) text(x = 0, y = .2, &quot;Data availability:&quot;, cex = 0.75, adj = c(0, 1), font = 2) text(x = .05, y = .1, &quot;\\u2022 Fragmented&quot;, cex = 0.75, adj = c(0, 1)) } # 23, 24 for (i in 1:2) { par(mar = c(0.1, 1, 0.1, 0.1)) plot0(x = c(0, 1)) text(x = 0.05, y = .95, &quot;Jurisdiction:&quot;, cex = 0.75, adj = c(0, 1), font = 2) text(x = 0.1, y = .85, &quot;\\u2022 Federal&quot;, cex = 0.75, adj = c(0, 1)) text(x = 0.05, y = .70, &quot;Spatial distribution:&quot;, cex = 0.75, adj = c(0, 1), font = 2) text(x = 0.1, y = .60, &quot;\\u2022 Regional&quot;, cex = 0.75, adj = c(0, 1)) text(x = 0.05, y = .45, &quot;Data collection protocols:&quot;, cex = 0.75, adj = c(0, 1), font = 2) text(x = 0.1, y = .35, &quot;\\u2022 Standardized&quot;, cex = 0.75, adj = c(0, 1)) text(x = 0.05, y = .2, &quot;Data availability:&quot;, cex = 0.75, adj = c(0, 1), font = 2) text(x = 0.1, y = .1, &quot;\\u2022 Regional&quot;, cex = 0.75, adj = c(0, 1)) } And here is the actual figure! "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
